#
# Contains helper functions for running Chimera in other CMake projects.
#

# TODO: DO NOT COMMIT THIS!
cmake_policy(SET CMP0026 OLD)

#
# Function to create a build target for a Chimera binding.
# The result of this operation is a CMake library target.
#
# add_chimera_binding(TARGET target
#                     DESTINATION destination_dir
#                     [MODULE module]  # Defaults to `target`
#                     [CONFIGURATION config_file]
#                     [SOURCES source1_file source2_file ...]
#                     [NAMESPACE namespace1 namespace2 namespace3])
function(add_chimera_binding)
    find_package(chimera REQUIRED)

    # Parse boolean, unary, and list arguments from input.
    # Unparsed arguments can be found in variable ARG_UNPARSED_ARGUMENTS.
    set(prefix binding)
    set(options DEBUG)
    set(oneValueArgs TARGET MODULE CONFIGURATION DESTINATION)
    set(multiValueArgs SOURCES NAMESPACES)
    cmake_parse_arguments("${prefix}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    # Print errors if arguments are missing.
    if(NOT binding_TARGET)
        message(FATAL_ERROR "Chimera requires a CMake TARGET name.")
    elseif(NOT binding_SOURCES)
        message(FATAL_ERROR "Chimera requires one or more SOURCES.")
    endif()

    # Default MODULE to be the same as TARGET.
    if(NOT binding_MODULE)
        set(binding_MODULE "${binding_TARGET}")
    endif()

    # Default DESTINATION to `./BINARY_DIR/TARGET`
    if(NOT binding_DESTINATION)
        set(binding_DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/${binding_TARGET}")
    endif()

    message("Provided sources are:")
    foreach(src ${binding_SOURCES})
        message("- ${src}")
    endforeach(src)

    # Create a placeholder library that depends on the provided sources.  This is used to
    # generate the necessary compilation database.
    set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
    set(binding_COMPILATION_DATABASE "${CMAKE_CURRENT_BINARY_DIR}/compile_commands.json")
    add_library("${binding_TARGET}_placeholder" SHARED EXCLUDE_FROM_ALL ${ARG_SOURCES})

    # Create an external target that re-runs chimera when any of the sources have changed.
    # This will necessarily invalidate a placeholder dependency that causes CMake to
    # rerun the compilation of the library if sources are regenerated.
    execute_process(
        COMMAND "${chimera_EXECUTABLE}"
            -m "${binding_MODULE}"
            # -c "${binding_CONFIGURATION}"
            -o "${binding_DESTINATION}"
            -p "${binding_COMPILATION_DATABASE}"
            ${binding_SOURCES}
        RESULT_VARIABLE binding_RESULT
        OUTPUT_VARIABLE binding_GENERATED
        # VERBATIM
    )

    if(NOT "${binding_RESULT}" EQUAL 0)
      message(FATAL_ERROR "Chimera failed to generate ${binding_TARGET}.")
    endif()

    foreach(x ${binding_CONFIGURATION} ${binding_COMPILATION_DATABASE} ${binding_SOURCES})
        configure_file(${x} ${x} COPYONLY)
    endforeach()

    # Combine the sources generated by chimera to create a new binding.
    add_library("${binding_TARGET}"
        ${binding_GENERATED}
    )
    add_dependencies("${ARG_TARGET}" "${CMAKE_CURRENT_BINARY_DIR}/${ARG_TARGET}_sources.txt")

endfunction(add_chimera_binding)